  <body>

    <!-- <div data-bs-spy="scroll" data-bs-target="#navbar-example3" data-bs-offset="0" class="scrollspy-example-2" tabindex="0"> -->
    <div class="p-m" id="p-m">
      <div class="p-top">
        <div class="row">
          <div class="p-top-postion">
            <h class="p-top-link" onclick="loadPage('home')">Journey</h>
            /
            <h class="p-top-link" onclick="loadPage('note')">笔记</h>
            /
            <h class="p-top-link" onclick="loadNote('Problem')"> 题解 </h>
            /
            <h class="p-top-link" onclick="loadXL('cf1820')"> Codeforces Round 866 (Div. 2)</h>
          </div>
        </div>
      </div>
      <div class="p-title2" id="item">Codeforces Round 866 (Div. 2)</div>
      <div class="p-title5">A. Yura's New Name</div>
      <div class="p-title5">B. JoJo's Incredible Adventures</div>
      <div class="p-title5">C. Constructive Problem</div>

      <div class="p-problem">
        <div class="p-title3" id="item-A">A. Yura's New Name</div>
        <div class="p-title4" id="item-A-1">题面：</div>
        <div class="p-word">
          <p class="p-word-title">Description</p>
          <div>
            After holding one team contest, boy Yura got very tired and wanted to change his life and move to Japan. In
            honor of such a change, Yura changed his name to something nice.
          </div>
          <div>
            Fascinated by this idea he already thought up a name sconsisting only of characters "_" and "^". But there's
            a problem — Yura likes smiley faces "^_^" and "^^". Therefore any character of the name must be a part of at
            least one such smiley. Note that only the consecutive characters of the name can be a smiley face.
          </div>
          <div>
            More formally, consider all occurrences of the strings "^_^" and "^^" in the string s. Then all such
            occurrences must cover the whole string s, possibly with intersections. For example, in the string
            "^^__^_^^__^" the characters at positions 3,4,9,10 and 11 are not contained inside any smileys, and the
            other characters at positions 1,2,5,6,7 and 8 are contained inside smileys.
          </div>
          <div>
            In one operation Jura can insert one of the characters "_" and "^" into his name s(you can insert it at any
            position in the string). He asks you to tell him the minimum number of operations you need to do to make the
            name fit Yura's criteria.
          </div>
          <br>
          <p class="p-word-title">Input</p>
          <div>
            Each test consists of multiple test cases. The first line contains a single integer t(1≤t≤100) —the number
            of test cases. The description of test cases follows.
          </div>
          <div>
            The first and only line of each test case contains a single string s (1≤|s|≤100), consisting of characters
            "_" and "^", — the name to change.
          </div>
          <br>
          <p class="p-word-title">Output</p>
          <div>
            For each test case, output a single integer — the minimum number of characters you need to add to the name
            to make it fit for Yura. If you don't need to change anything in the name, print 0.
          </div>
        </div>
        <div class="p-title4" id="item-A-2">题意：</div>
        <div class="p-word">
          <div>
            Yura 要改名字，他想取一个只包含字符 _ 和 ^ 的名字，并满足一定条件，即只有形如 "^_^" 和 "^^"
            的连续子串可以出现在该名字中，且这些子串能够覆盖整个名字，不同子串间可以重叠。每次操作可以在名字中插入一个字符 _ 或一个字符 ^，求最少需要多少次操作才能使其符合要求。
          </div>
        </div>
        <div class="p-title4" id="item-A-3">思路：</div>
        <div class="p-word">
          <div>
            如果长度为一,判断是_还是^
          </div>
          <div>
            如果长度大于1,分别讨论_开头和^开头
          </div>
        </div>
        <div class="p-title4" id="item-A-4">代码：</div>
        <div class="p-code">
          <pre><code class="cpp">
                  <xmp>
    #include <bits/stdc++.h>
    using namespace std; 
    const int inf=0x3f3f3f3f;
    const long long INF=0x3f3f3f3f3f3f3f3f;
    const int maxn=2e5+50;
    const int mod=998244353;
    const int Mod=1e9+7;
    typedef long long ll;
    int main()
    {
        std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
        ll T;
        cin >> T;
        while (T--)
        {
            string s;
            cin >> s;
            ll ans=0;
            if (s[0]=='_' || (s.size()==1 && s[0]=='^')) ans++;
            for (int i=0; i<s.size(); i++)
                if (s[i]!='^' && (i==s.size()-1 || s[i+1]!='^'))
                ans++;
            cout << ans << "\n";
        }
    }</xmp>
              </code></pre>
        </div>

      </div>
      <div class="p-problem">
        <div class="p-title3" id="item-B">B. JoJo's Incredible Adventures</div>
        <div class="p-title4" id="item-B-1">题面：</div>
        <div class="p-word">
          <p class="p-word-title">Description</p>
          <div>
            Did you think there was going to be a JoJo legend here? But no, that was me, Dio!
          </div>
          <div>
            Given a binary string s of length n , consisting of characters 0 and 1. Let's build a square table of size
            n×n , consisting of 0 and 1 characters as follows.
          </div>
          <div>
            In the first row of the table write the original string s. In the second row of the table write cyclic shift
            of the string s by one to the right. In the third row of the table, write the cyclic shift of line s by two
            to the right. And so on. Thus, the row with number k will contain a cyclic shift of string s by k to the
            right. The rows are numbered from 0 to n−1 top-to-bottom.
          </div>
          <div>
            In the resulting table we need to find the rectangle consisting only of ones that has the largest area.
          </div>
          <div>
            We call a rectangle the set of all cells (i,j) in the table, such that x1≤i≤x2 and y1≤j≤y2 for some integers
            0≤x1≤x2&lt;n and 0≤y1≤y&lt;n.
          </div>
          <br>
          <p class="p-word-title">Input</p>
          <div>
            Each test consists of multiple test cases. The first line contains a single integer t (1≤t≤2e4) — the number
            of test cases. The description of test cases follows.
          </div>
          <div>
            The first and the only line of each test case contains a single binary string s (1≤|s|≤2e5), consisting of
            characters 0 and 1.
          </div>
          <div>
            It is guaranteed that the sum of string lengths |s| over all test cases does not exceed 2e5.
          </div>
          <br>
          <p class="p-word-title">Output</p>
          <div>
            For each test case, output a single integer — the maximum area of a rectangle consisting only of ones. If
            there is no such rectangle, output 0.
          </div>
        </div>
        <div class="p-title4" id="item-B-2">题意：</div>
        <div class="p-word">
          <div>
            给定一个长度为n的01字符串， 每次将整个串整体往后移，最后一个移到开头，作为下一行，问存在的全1矩形的最大面积
          </div>
        </div>
        <div class="p-title4" id="item-B-3">思路：</div>
        <div class="p-word">
          <div>
            模拟数据即可发现规律
          </div>
        </div>
        <div class="p-title4" id="item-B-4">代码：</div>
        <div class="p-code">
          <pre><code class="cpp">
                  <xmp>
    #include <bits/stdc++.h>
    using namespace std; 
    const int inf=0x3f3f3f3f;
    const long long INF=0x3f3f3f3f3f3f3f3f;
    const int maxn=2e5+50;
    const int mod=998244353;
    const int Mod=1e9+7;
    typedef long long ll;
    int main()
    {
        std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
        ll T;
        cin >> T;
        while (T--)
        {
            string s;
            cin >> s;
            s+=s; 
            ll mx=0,cnt=0;
            for (int i=0; i<s.size(); i++)
            {
                if (s[i]=='1') cnt++;
                else
                {
                    mx=max(mx,cnt);
                    cnt=0;
                }
            }
            mx=max(mx,cnt);
            if (mx==s.size()) cout << mx/2*mx/2 << "\n";
            else {
            //	cout << " " << mx << "\n";
                cout << ((mx+1)/2)*(mx+1-(mx+1)/2) << "\n";
            }
        }
    }</xmp>
              </code></pre>
        </div>

      </div>
      <div class="p-problem">
        <div class="p-title3" id="item-C">C. Constructive Problem</div>
        <div class="p-title4" id="item-C-1">题面：</div>
        <div class="p-word">
          <div class="p-word-title">Description</div>
          <div>
            As you know, any problem that does not require the use of complex data structures is considered
            constructive. You are offered to solve one of such problems.
          </div>
          <div>
            You are given an array a of n non-negative integers. You are allowed to perform the following operation
            exactly once: choose some non-empty subsegment al,al+1,…,ar of the array a and a non-negative integer k ,
            and assign value k to all elements of the array on the chosen subsegment.
          </div>
          <div>
            The task is to find out whether MEX(a) can be increased by exactly one by performing such an operation. In
            other words, if before the operation MEX(a)=m held, then after the operation it must hold that MEX(a)=m+1.
          </div>
          <div>
            Recall that MEX of a set of integers c1,c2,…,ck is defined as the smallest non-negative integer x which does
            not occur in the set c.
          </div>
          <br>
          <div class="p-word-title">Input</div>
          <div>
            Each test contains multiple test cases. The first line contains the number of test cases t 1≤t≤50000 ) — the
            number of test cases. The description of the test cases follows.
          </div>
          <div>
            The first line of each test case contains a single integer n (1≤n≤200000) — the number of elements of array
            a.
          </div>
          <div>
            The second line of each test case contains n integers a1,a2,…,an (0≤ai≤1e9) — elements of array a.
          </div>
          <div>
            It is guaranteed that the sum n over all test cases does not exceed 200000.
          </div>
          <br>

          <div class="p-word-title">Output</div>
          <div>
            For each test case, print "Yes" if you can increase MEX(a) by exactly one by performing the operation from
            the statement exactly once, otherwise print "No".
          </div>
          <div>
            You can output the answer in any case (upper or lower). For example, the strings "yEs", "yes", "Yes", and
            "YES" will be recognized as positive responses.
          </div>
        </div>
        <div class="p-title4" id="item-C-2">题意：</div>
        <div class="p-word">
          <div>
            给定一个长度为n的01字符串， 每次将整个串整体往后移，最后一个移到开头，作为下一行，问存在的全1矩形的最大面积
          </div>
        </div>
        <div class="p-title4" id="item-C-3">思路：</div>
        <div class="p-word">
          <div>
            模拟数据即可发现规律
          </div>
        </div>
        <div class="p-title4" id="item-C-4">代码：</div>
        <div class="p-code">
          <pre><code class="cpp">
                  <xmp>
      #include <bits/stdc++.h>
      using namespace std; 
      const int inf=0x3f3f3f3f;
      const long long INF=0x3f3f3f3f3f3f3f3f;
      const int maxn=2e5+50;
      const int mod=998244353;
      const int Mod=1e9+7;
      typedef long long ll;
      int main()
      {
          std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
          ll T;
          cin >> T;
          while (T--)
          {
              ll n;
              cin >> n;
              map <ll,ll> l,r;
              for (int i=1; i<=n; i++)
              {
                  ll x;
                  cin >> x;
                  if (!r[x]) l[x]=i;
                  r[x]=i;
              }
              ll m=0;
              while (l[m]) m++;
              if (!l[m+1]) 
              {
                  if (m!=n) cout << "Yes\n";
                  else cout << "No\n";
                  continue;
              }
              ll f=1;
              for (int i=0; i<m; i++)
                  if (l[m+1]<l[i] && r[i]<r[m+1]) f=0;
              if (f) cout << "Yes\n";
              else cout << "No\n";
          }
      }</xmp>
              </code></pre>
        </div>

      </div>

      <div class="p-bot">
        <div class="p-date">
          <div>
            首次发布时间:2023年5月15日
          </div>
          <div>
            最后修改时间:2023年5月24日
          </div>
          <div>
            发布者:@Journey
          </div>
        </div>
      </div>
      <div class="copyright colorfulword">Copyright © CKZ</div>
    </div>
  </body>